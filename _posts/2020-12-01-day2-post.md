---
title: "Day2-자료구조(2)"
date: 2020-12-01
categories: TIL
---
## 12월 01일 화

어제 공부했던 자료구조인 리스트, 연결 리스트에 이어서 자료구조를 공부했다.  
스택, 큐, 트리, 힙에 대해 공부했고 자료구조에 대한 구현과 자료구조를 이용해서 풀수 있는 예제들을 풀어보았다.  
여러 자료구조들을 복습해보면서 개념을 정리하는 데에 도움이 되었고 Python을 다루는 것이 조금 더 익숙해 진것 같다.  
예제를 풀면서 발생한 대부분의 에러들이 C와 Python의 문법을 혼동하여 생긴 것인만큼 아직 완전히 익숙하진 않지만 시행착오를 거치고 나니 Python스럽게 코딩하는 방법을 점점 습득해 나가고 있는것 같다.

## 스택(Stack)  

**스택**  
자료를 보관할 수 있는 선형 구조
- 넣을 때는 한쪽 끝에서 밀어넣어야 하고 (push)
- 꺼낼 때는 같은 쪽에서 뽑아 꺼내야 한다. (pop)  
=> LIFO(last in last out)의 특징을 가지고 있는 선형 자료구조이다.

**연산의 정의**
- `size()`: 스택의 전체 크기를 반환
- `isEmpty()`: 스택이 비어있는지 여부를 반환
- `push(val)`: 스택의 맨 끝에 값을 추가
- `pop()`: 스택의 맨 끝 값을 삭제 후 그 값을 반환
- `peek()`: 스택의 맨 끝 값을 반환

### 스택의 구현
1. 배열을 이용하여 구현  
Python 리스트와 메서드들을 이용하여 구현할 수 있다.
```python
class ArrayStack:
    def __init__(self):
        self.data = []

    def size(self):                   #O(1)
        return len(self.data)
  
    def isEmpty(self):                #O(1)
        return self.size() == 0

    def push(self, item):             #O(1)
        self.data.append(item)

    def pop(self):                    #O(1)
        return self.data.pop()

    def peek(self):                   #O(1)
        return self.data[-1]
```
<p>&nbsp;</p>  

2. 연결 리스트를 이용하여 구현  
양방향 연결 리스트를 이용하여 구현 할 수 있다.  
```python
class dLinkedListStack:
    def __init__(self):                             #O(1)
        self.data = DoublyLinkedList()
    
    def size(self):                                 #O(1)
        return self.data.getLength()
    
    def isEmpty(self):                              #O(1)
        return self.size() == 0
    
    def push(self,item):                            #O(1)
        node = Node(item)
        self.data.insertAt(self.size() + 1, node)
    
    def pop(self):                                  #O(1)
        return self.data.popAt(self.size())
        
    def peek(self):                                 #O(1)
        return self.data.getAt(self.size()).data
```
<p>&nbsp;</p>  

위의 코드에서 양방향 연결 리스트의 `insertAt`,  `popAt`과 `getAt`은 시간 복잡도가 `O(n)`으로 알고 있지만 `O(1)`인 이유는 양방향 리스트는 알아서 head와 tail중 가까운곳을 찾아서 탐색하고 스택에서는 항상 맨 끝의 노드를 삭제, 삽입, 검색 하므로 연산을 할 위치를 한번에 찾게된다. 따라서 시간복잡도는 `O(1)`이 된다.  
=> 배열을 이용하여 구현하나 연결 리스트를 이용하여 구현하나 모든 연산의 시간복잡도는 `O(1)`이므로 크게 상관없다.

### 스택의 응용

**수식의 괄호 검사**  
수식에서 괄호과 올바르게 되어 있는지 확인  
ex) {(1+2)+3}+4 O,  (1+{2+3)+4} X  

알고리즘  
1. 수식을 왼쪽에서 한개씩 읽음
2. 여는 괄호를 만나면 스택에 push
3. 닫는 괄호를 만나면
4. pop을 해서 나오는 괄호가 쌍을 이루는지 확인
5. 쌍을 이루지 않는다면 올바르지 않은 수식
6. 끝까지 진행 후 스택이 비어있다면 올바른 수식  

```python
def solution(expr):
    match = {                   #순서쌍을 dictionary에 저장
        ')': '(',
        '}': '{',
        ']': '['
    }
    S = ArrayStack()            #빈 스택을 생성
    for c in expr:              #수식을 순회
        if c in '({[':          #여는 괄호라면 push
            S.push(c)
        elif c in match:        #여는 괄호가 아니라면
            if S.isEmpty():     #스택이 비어있다면 False를 반환
                return False
            else:    
                t = S.pop()
            if t != match[c]:   #쌍을 이루지 않는다면 False
                return False
    return S.isEmpty()          #마지막에 스택이 비었다면 True
```
<p>&nbsp;</p>  

**수식의 후위 표기법**  
- 중위표기법(infix notaion): 우리가 일반적으로 사용하는 연산자가 피연산자들의 사이에 위치
- 후위표기법(postfix notation): 연산자가 피연산자들의 뒤에 위치








